> """
> PostgreSQL database interface module.
  
> This module provides a comprehensive PostgreSQL database interface with:
> - SQLAlchemy-based connection management
> - Query logging and performance monitoring
> - Database migration support
> - Read-only connection support
> - Session management with proper cleanup
> """
  
> import abc
> import time
> import re
> import collections
> import warnings
> from functools import lru_cache
> from typing import Any, Optional, Dict
  
> import sqlalchemy
> import sqlalchemy.sql
> import sqlalchemy.orm
> import sqlalchemy.dialects.postgresql
> import sqlalchemy_utils
> from sqlalchemy.exc import SAWarning
  
> from ...log import LoggerFactory, resolve_level
> from ... import utils
> from ... import time as infratime
> from .interface import Interface
  
  # Suppress SQLAlchemy NULL comparison warnings when rendering literal binds for logging
> warnings.filterwarnings(
>     "ignore", message=".*Bound parameter.*rendering literal NULL.*", category=SAWarning
> )
  
  
  # Helper functions for PG.__init__()
  
  
> def _validate_init_params(lg: Any, cfg: Any) -> None:
>     """Validate logger and config parameters."""
>     if lg is None:
!         raise ValueError("Logger cannot be None")
>     if cfg is None:
!         raise ValueError("Configuration cannot be None")
  
  
> def _create_sqlalchemy_engine(url: str) -> sqlalchemy.engine.Engine:
>     """Create SQLAlchemy engine from URL."""
!     return sqlalchemy.create_engine(url, poolclass=sqlalchemy.pool.NullPool)
  
  
> def _apply_readonly_mode(engine: sqlalchemy.engine.Engine, readonly: bool) -> None:
>     """Apply readonly mode to engine if configured."""
!     if readonly:
  
!         @sqlalchemy.event.listens_for(engine, "connect")
!         def set_readonly(dbapi_conn: Any, connection_record: Any) -> None:
!             cursor = dbapi_conn.cursor()
!             cursor.execute("SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY")
!             cursor.close()
  
  
> def _initialize_performance_cache(pg_instance: "PG") -> None:
>     """Initialize performance-related cached attributes."""
!     pg_instance._dialect = pg_instance._engine.dialect
!     pg_instance._cached_regex = re.compile(r"\n\s+")
  
  
> def _create_engine_and_session(cfg: Any) -> tuple[sqlalchemy.engine.Engine, Any]:
>     """Create SQLAlchemy engine and session factory."""
!     engine_kwargs = {"poolclass": sqlalchemy.pool.NullPool}
!     engine = sqlalchemy.create_engine(cfg.url, **engine_kwargs)
!     session_cls = sqlalchemy.orm.sessionmaker(bind=engine)
!     return engine, session_cls
  
  
> def _configure_readonly_mode(pg_instance: "PG") -> None:
>     """Configure readonly mode with validation."""
>     if pg_instance.readonly is True:
!         if pg_instance._cfg.get("create_db", False) is True:
!             raise ValueError("Cannot create database in read-only mode")
!         pg_instance._engine = pg_instance._engine.execution_options(
!             postgresql_readonly=True
!         )
  
  
> def _initialize_logging_context(pg_instance: "PG", query_lg_level: Any) -> None:
>     """Initialize logging context and query log level."""
>     pg_instance._lg_extra = {
>         "url": pg_instance._engine.url,
>         "readonly": pg_instance.readonly,
>     }
>     pg_instance._query_lg_level = (
>         resolve_level(query_lg_level) if query_lg_level is not None else None
>     )
  
  
> def _initialize_connection_health(pg_instance: "PG") -> None:
>     """Initialize connection health tracking attributes."""
>     pg_instance._connection_healthy = True
>     pg_instance._auto_reconnect = pg_instance._cfg.get("auto_reconnect", True)
>     pg_instance._max_retries = pg_instance._cfg.get("max_retries", 3)
>     pg_instance._retry_delay = pg_instance._cfg.get("retry_delay", 1.0)
  
  
> def _initialize_performance_optimizations(pg_instance: "PG") -> None:
>     """Initialize performance optimization caches."""
>     pg_instance._whitespace_regex = re.compile(r"\s+")
>     pg_instance._dialect = sqlalchemy.dialects.postgresql.dialect()
  
  
  # Helper functions for PG._setup_callbacks()
  
  
> def _log_query_with_timing(
>     lg: Any, query_lg_level: int, secs: float, qstr: str, url: Any
> ) -> None:
>     """Log query execution with timing information."""
!     try:
!         extra = {"after": secs, "query": qstr, "url": url}
!         if lg.isEnabledFor(query_lg_level):
!             lg._log(query_lg_level, "db query", (), extra=extra)
!     except Exception as e:
          # Emergency fallback: write to stderr if custom logging fails
!         import sys
  
!         sys.stderr.write(
!             f"!!!!!!! UNABLE TO LOG: error[{e}] msg[db query] extra[{extra}]\n"
!         )
  
  
  # Helper functions for PG.connect()
  
  
> def _validate_readonly_config(readonly: bool, create_db: bool) -> None:
>     """Validate readonly and create_db settings don't conflict."""
>     if readonly and create_db:
!         raise ValueError("Cannot create database in readonly mode")
  
  
> def _handle_database_creation(
>     engine: sqlalchemy.engine.Engine,
>     lg: Any,
>     lg_extra: Dict[str, Any],
>     start_time: float,
> ) -> None:
>     """Create database if it doesn't exist."""
>     if not sqlalchemy_utils.database_exists(engine.url):
!         sqlalchemy_utils.create_database(engine.url)
!         lg.info("created db", extra=lg_extra | {"after": infratime.since(start_time)})
  
  
> def _handle_sqlalchemy_error(
>     lg: Any, lg_extra: Dict[str, Any], error: Exception, start_time: float
> ) -> None:
>     """Handle SQLAlchemy connection errors."""
!     lg.error(
!         "failed to connect to db",
!         extra=lg_extra | {"after": infratime.since(start_time), "error": str(error)},
!     )
!     raise
  
  
> def _handle_general_error(
>     lg: Any, lg_extra: Dict[str, Any], error: Exception, start_time: float
> ) -> None:
>     """Handle general connection errors by wrapping in SQLAlchemyError."""
!     lg.error(
!         "unexpected error connecting to db",
!         extra=lg_extra | {"after": infratime.since(start_time), "error": str(error)},
!     )
!     raise sqlalchemy.exc.SQLAlchemyError(
!         f"Database connection failed: {error}"
!     ) from error
  
  
> class PG(Interface):
>     """
>     PostgreSQL database interface implementation.
  
>     Provides a complete PostgreSQL database interface with SQLAlchemy integration,
>     including connection management, query logging, migration support, and
>     read-only connection capabilities.
>     """
  
>     def __init__(self, lg: Any, cfg: Any, query_lg_level: Optional[Any] = None) -> None:
>         """
>         Initialize the PostgreSQL database interface.
  
>         Args:
>             lg: Logger instance for database operations
>             cfg: Database configuration object
>             query_lg_level: Log level for query logging (optional)
>         """
>         _validate_init_params(lg, cfg)
  
>         self._cfg = cfg
>         self._lg = LoggerFactory.derive(lg, "pg")
>         self._validate_config()
  
          # Create engine and session
>         engine_kwargs = self._get_engine_kwargs()
>         self._engine = sqlalchemy.create_engine(self._cfg.url, **engine_kwargs)
>         self._SessionCls = sqlalchemy.orm.sessionmaker(bind=self._engine)
  
          # Configure readonly mode
>         _configure_readonly_mode(self)
  
          # Initialize subsystems
>         _initialize_logging_context(self, query_lg_level)
>         _initialize_performance_optimizations(self)
>         _initialize_connection_health(self)
  
          # Set up query logging callbacks
>         self._setup_callbacks()
  
>     @lru_cache(maxsize=1000)
>     def _format_query_string(self, query_str: str) -> str:
>         """
>         Format query string with caching for better performance.
  
>         Args:
>             query_str: Raw query string to format
  
>         Returns:
>             Formatted query string with normalized whitespace
>         """
          # More efficient than multiple replace calls + regex
!         formatted = self._whitespace_regex.sub(
!             " ", query_str.replace("\n", " ").replace("\t", " ")
!         )
!         return formatted.strip()
  
>     def _validate_config(self) -> None:
>         """
>         Validate database configuration.
  
>         Raises:
>             ValueError: If configuration is invalid
>         """
>         if not hasattr(self._cfg, "url") or not self._cfg.url:
!             raise ValueError("Database URL is required")
  
>         if not isinstance(self._cfg.url, str):
!             raise ValueError("Database URL must be a string")
  
>         if not self._cfg.url.startswith(("postgresql://", "postgres://")):
!             raise ValueError(
!                 "Database URL must start with 'postgresql://' or 'postgres://'"
!             )
  
>     def _get_engine_kwargs(self) -> Dict[str, Any]:
>         """
>         Get SQLAlchemy engine configuration parameters.
  
>         Returns:
>             dict: Engine configuration parameters
>         """
>         kwargs = {
>             "pool_size": self._cfg.get("pool_size", 5),
>             "max_overflow": self._cfg.get("max_overflow", 10),
>             "pool_timeout": self._cfg.get("pool_timeout", 30),
>             "pool_recycle": self._cfg.get("pool_recycle", 3600),
>             "pool_pre_ping": self._cfg.get("pool_pre_ping", True),
>             "echo": self._cfg.get("echo", False),
>         }
  
          # Remove None values
>         return {k: v for k, v in kwargs.items() if v is not None}
  
>     def _create_after_execute_hook(self) -> Any:
>         """Create and return the after_execute event listener."""
  
>         @sqlalchemy.event.listens_for(self._engine, "after_execute")
>         def _after_execute(
>             conn, clauseelement, multiparams, params, execution_options, result
>         ):
>             """Log query execution details after completion."""
>             secs = time.monotonic() - conn.info["query_start_time"].pop(-1)
>             if self._query_lg_level is None:
>                 return
  
!             comp = clauseelement.compile(
!                 dialect=self._dialect, compile_kwargs={"literal_binds": True}
!             )
!             qstr = self._format_query_string(str(comp))
!             _log_query_with_timing(
!                 self._lg, self._query_lg_level, secs, qstr, self._engine.url
!             )
  
>         return _after_execute
  
>     def _setup_callbacks(self) -> None:
>         """
>         Set up SQLAlchemy event listeners for query logging and monitoring.
  
>         Configures callbacks to track query execution times and log SQL statements
>         when query logging is enabled.
>         """
  
>         @sqlalchemy.event.listens_for(self._engine, "before_cursor_execute")
>         def _record_query_start(
>             conn: Any,
>             cursor: Any,
>             statement: str,
>             parameters: Any,
>             context: Any,
>             executemany: bool,
>         ) -> None:
>             """Record the start time of query execution."""
>             conn.info.setdefault("query_start_time", []).append(time.monotonic())
>             if self._query_lg_level is not None:
!                 self._lg.trace2("query start")
  
>         self._lg.debug("created db interface", extra={"url": self._engine.url})
>         self._create_after_execute_hook()
>         self._lg.trace2(
>             "created after_execute hook for logging", extra={"url": self._engine.url}
>         )
  
>     @property
>     def cfg(self) -> Any:
>         """
>         Get the database configuration.
  
>         Returns:
>             Configuration object for the database
>         """
!         return self._cfg
  
>     @property
>     def url(self) -> Any:
>         """
>         Get the database connection URL.
  
>         Returns:
>             str: Database connection URL
>         """
!         return self._engine.url
  
>     @property
>     def readonly(self) -> bool:
>         """
>         Check if the database connection is in read-only mode.
  
>         Returns:
>             bool: True if the connection is read-only
>         """
>         return self._cfg.get("readonly", False)
  
>     def connect(self) -> Any:
>         """
>         Establish a connection to the PostgreSQL database.
  
>         Handles database creation if specified in configuration and ensures
>         proper connection setup with logging and timing information.
  
>         Returns:
>             Database connection object
  
>         Raises:
>             sqlalchemy.exc.SQLAlchemyError: If connection fails
>             ValueError: If configuration is invalid
>         """
>         start = infratime.start()
>         self._lg.trace("connecting to db...", extra=self._lg_extra)
  
>         create_db = self._cfg.get("create_db", False)
>         _validate_readonly_config(self.readonly, create_db)
  
>         if self.readonly:
!             self._lg.trace("db conn set to readonly", extra=self._lg_extra)
  
>         try:
>             if create_db:
>                 _handle_database_creation(self._engine, self._lg, self._lg_extra, start)
  
>             conn = self._engine.connect()
>             self._lg.debug(
>                 "connected to db",
>                 extra=self._lg_extra | {"after": infratime.since(start)},
>             )
>             return conn
  
!         except sqlalchemy.exc.SQLAlchemyError as e:
!             _handle_sqlalchemy_error(self._lg, self._lg_extra, e, start)
!         except Exception as e:
!             _handle_general_error(self._lg, self._lg_extra, e, start)
  
>     @property
>     def engine(self) -> sqlalchemy.engine.Engine:
>         """
>         Get the SQLAlchemy engine.
  
>         Returns:
>             sqlalchemy.Engine: Database engine instance
>         """
!         return self._engine
  
>     def migrate(self, base: Any) -> None:
>         """
>         Run database migrations using SQLAlchemy metadata.
  
>         Creates all tables defined in the metadata if they don't exist.
  
>         Args:
>             base: SQLAlchemy declarative base with metadata
>         """
          # Ensure database exists if create_db is enabled
!         create_db = self._cfg.get("create_db", False)
!         if create_db is True and not sqlalchemy_utils.database_exists(self._engine.url):
!             sqlalchemy_utils.create_database(self._engine.url)
!             self._lg.info("created db", extra=self._lg_extra)
  
!         base.metadata.create_all(self._engine)
  
>     def _ensure_connection_healthy(self) -> None:
>         """
>         Ensure connection is healthy before creating session.
  
>         Proactively reconnects if auto_reconnect enabled and connection unhealthy.
>         """
>         if self._auto_reconnect and not self._connection_healthy:
!             if not self._check_connection():
!                 self._lg.info("connection unhealthy, attempting reconnect")
!                 self.reconnect()
  
>     def _create_session_with_retry(self) -> Any:
>         """
>         Create session with automatic retry on failure.
  
>         Returns:
>             sqlalchemy.orm.Session: Database session instance
  
>         Raises:
>             sqlalchemy.exc.SQLAlchemyError: If session creation fails
>         """
>         try:
>             session = self._SessionCls()
>             self._lg.trace("created database session", extra=self._lg_extra)
>             return session
!         except Exception as e:
!             self._connection_healthy = False
!             if self._auto_reconnect:
!                 return self._retry_session_after_reconnect(e)
!             else:
!                 return self._raise_session_error(e)
  
>     def _retry_session_after_reconnect(self, original_error: Exception) -> Any:
>         """
>         Retry session creation after reconnecting.
  
>         Args:
>             original_error: The original exception that triggered retry
  
>         Returns:
>             sqlalchemy.orm.Session: Database session instance
  
>         Raises:
>             sqlalchemy.exc.SQLAlchemyError: If retry fails
>         """
!         self._lg.info("session creation failed, attempting reconnect")
!         try:
!             self.reconnect()
!             session = self._SessionCls()
!             self._lg.trace(
!                 "created database session after reconnect", extra=self._lg_extra
!             )
!             return session
!         except Exception as reconnect_error:
!             self._lg.error(
!                 "failed to create session even after reconnect",
!                 extra=self._lg_extra | {"error": str(reconnect_error)},
!             )
!             raise sqlalchemy.exc.SQLAlchemyError(
!                 f"Session creation failed after reconnect: {reconnect_error}"
!             ) from reconnect_error
  
>     def _raise_session_error(self, error: Exception) -> None:
>         """
>         Raise session creation error.
  
>         Args:
>             error: The original exception
  
>         Raises:
>             sqlalchemy.exc.SQLAlchemyError: Always raises
>         """
!         self._lg.error(
!             "failed to create database session",
!             extra=self._lg_extra | {"error": str(error)},
!         )
!         raise sqlalchemy.exc.SQLAlchemyError(
!             f"Session creation failed: {error}"
!         ) from error
  
>     def session(self) -> Any:
>         """
>         Create a new database session with automatic reconnection if enabled.
  
>         If auto_reconnect is enabled and the connection is unhealthy,
>         this method will attempt to reconnect before creating the session.
  
>         Returns:
>             sqlalchemy.orm.Session: Database session instance
  
>         Raises:
>             sqlalchemy.exc.SQLAlchemyError: If session creation fails
>             DatabaseError: If reconnection fails (when auto_reconnect is enabled)
>         """
>         self._ensure_connection_healthy()
>         return self._create_session_with_retry()
  
>     def health_check(self) -> Dict[str, Any]:
>         """
>         Perform a health check on the database connection.
  
>         Returns:
>             dict: Health check results with status and timing information
>         """
!         start = infratime.start()
!         try:
              # Simple health check - execute a basic query
!             conn = self.connect()
!             result = conn.execute(sqlalchemy.text("SELECT 1"))
!             conn.close()
  
!             elapsed = infratime.since(start)
!             self._lg.debug(
!                 "health check passed", extra=self._lg_extra | {"after": elapsed}
!             )
  
!             return {
!                 "status": "healthy",
!                 "response_time_ms": elapsed * 1000,
!                 "error": None,
!             }
  
!         except Exception as e:
!             elapsed = infratime.since(start)
!             self._lg.error(
!                 "health check failed",
!                 extra=self._lg_extra | {"error": str(e), "after": elapsed},
!             )
  
!             return {
!                 "status": "unhealthy",
!                 "response_time_ms": elapsed * 1000,
!                 "error": str(e),
!             }
  
>     def get_pool_status(self) -> Dict[str, Any]:
>         """
>         Get connection pool status information.
  
>         Returns:
>             dict: Pool status including size, checked out connections, etc.
>         """
!         pool = self._engine.pool
!         status = {
!             "pool_size": pool.size(),
!             "checked_out": pool.checkedout(),
!             "overflow": pool.overflow(),
!             "checked_in": pool.checkedin(),
!             "total_connections": pool.size() + pool.overflow(),
!         }
  
          # Add invalid count if the method exists
!         if hasattr(pool, "invalid"):
!             status["invalid"] = pool.invalid()
!         else:
!             status["invalid"] = 0
  
!         return status
  
>     def _check_connection(self, timeout: float = 5.0) -> bool:
>         """
>         Check if database connection is healthy.
  
>         Args:
>             timeout: Query timeout in seconds (default: 5.0)
  
>         Returns:
>             bool: True if connection is healthy, False otherwise
>         """
!         try:
              # Quick health check with timeout
!             with self._engine.connect() as conn:
!                 conn.execute(
!                     sqlalchemy.text("SELECT 1").execution_options(timeout=timeout)
!                 )
!             self._connection_healthy = True
!             return True
!         except Exception as e:
!             self._lg.warning(
!                 "connection health check failed",
!                 extra=self._lg_extra | {"error": str(e)},
!             )
!             self._connection_healthy = False
!             return False
  
>     def _attempt_single_reconnect(self, attempt_num: int) -> bool:
>         """
>         Attempt a single reconnection.
  
>         Args:
>             attempt_num: Current attempt number (for logging)
  
>         Returns:
>             bool: True if reconnection successful
>         """
!         try:
!             self._engine.dispose()
!             if self._check_connection():
!                 self._lg.info(
!                     "reconnected to database",
!                     extra=self._lg_extra | {"attempt": attempt_num},
!                 )
!                 return True
!         except Exception as e:
!             self._lg.warning(
!                 f"reconnection attempt {attempt_num} failed",
!                 extra=self._lg_extra | {"error": str(e)},
!             )
!         return False
  
>     def _execute_reconnect_with_backoff(self, max_retries: int, delay: float) -> bool:
>         """
>         Execute reconnection attempts with exponential backoff.
  
>         Args:
>             max_retries: Maximum retry attempts
>             delay: Initial delay between retries
  
>         Returns:
>             bool: True if any attempt succeeded
  
>         Raises:
>             DatabaseError: If all retries exhausted
>         """
!         from ...exceptions import DatabaseError
  
!         for attempt in range(max_retries):
!             if self._attempt_single_reconnect(attempt + 1):
!                 return True
  
              # Exponential backoff before next retry
!             if attempt < max_retries - 1:
!                 wait_time = delay * (2**attempt)
!                 self._lg.debug(
!                     f"waiting {wait_time:.2f}s before retry",
!                     extra=self._lg_extra,
!                 )
!                 time.sleep(wait_time)
  
          # All retries exhausted
!         self._connection_healthy = False
!         error_msg = f"Failed to reconnect after {max_retries} attempts"
!         self._lg.error(error_msg, extra=self._lg_extra)
!         raise DatabaseError(error_msg, url=str(self._engine.url), retries=max_retries)
  
>     def reconnect(
>         self, max_retries: Optional[int] = None, initial_delay: Optional[float] = None
>     ) -> bool:
>         """
>         Reconnect to the database with exponential backoff.
  
>         Args:
>             max_retries: Maximum number of retry attempts (default: from config)
>             initial_delay: Initial retry delay in seconds (default: from config)
  
>         Returns:
>             bool: True if reconnection successful
  
>         Raises:
>             DatabaseError: If reconnection fails after all retries
>         """
!         max_retries = max_retries if max_retries is not None else self._max_retries
!         delay = initial_delay if initial_delay is not None else self._retry_delay
!         self._lg.info("attempting to reconnect to database", extra=self._lg_extra)
!         return self._execute_reconnect_with_backoff(max_retries, delay)
