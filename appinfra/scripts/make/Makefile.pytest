# Makefile.pytest - Pytest-based Testing Targets
#
# Provides: test.unit, test.integration, test.e2e, test.coverage, etc.
# Requires: PYTHON (from Makefile.env)
#
# Configuration variables (set in Makefile before include):
#   INFRA_PYTEST_COVERAGE_PKG       - Package to measure coverage for (default: INFRA_DEV_PKG_NAME)
#   INFRA_PYTEST_COVERAGE_MARKERS   - Pytest markers for coverage tests (default: unit)
#                                     Set empty to include all tests in coverage
#   INFRA_PYTEST_COVERAGE_THRESHOLD - Coverage threshold for make check (default: 95.0)
#                                     Set to 0 to disable coverage checking entirely
#   INFRA_PYTEST_TESTS_DIR          - Tests directory (default: tests)
#   INFRA_PYTEST_ARGS               - Additional pytest arguments (default: empty)

# Configuration (defaults set in Makefile.config)
INFRA_PYTEST_TESTS_DIR ?= tests
INFRA_PYTEST_ARGS ?=

# Coverage output directory (under project root)
_COVERAGE_DIR := $(INFRA_DEV_PROJECT_ROOT)/.coverage

# Build marker argument for coverage tests (empty if no markers specified)
_COVERAGE_MARKER_ARG := $(if $(INFRA_PYTEST_COVERAGE_MARKERS),-m "$(INFRA_PYTEST_COVERAGE_MARKERS)",)

# Helper to check pytest availability with helpful error
define _check_pytest
@$(PYTHON) -c "import pytest" 2>/dev/null || { \
	echo ""; \
	echo "ERROR: pytest not installed"; \
	echo ""; \
	echo "To fix, run one of:"; \
	echo "  $(PYTHON) -m pip install pytest pytest-xdist pytest-cov"; \
	echo "  make setup"; \
	echo ""; \
	exit 1; \
}
endef

# Helper to run pytest, treating "no tests collected" (exit 5) as success
# Usage: $(call run_pytest,args)
define run_pytest
$(PYTHON) -m pytest $(1) || { ec=$$?; [ $$ec -eq 5 ] && exit 0 || exit $$ec; }
endef

##@ Testing

test.unit:: ## runs unit tests (fast, isolated, mocked dependencies)
	@echo "* running unit tests..."
	@$(call run_pytest,tests/ -m unit -qq --tb=short)
	@echo "* unit tests done"
.PHONY: test.unit

test.unit.v:: ## runs unit tests (verbose)
	@echo "* running unit tests... (verbose)"
	@$(call run_pytest,tests/ -m unit -v)
	@echo "* unit tests done"
.PHONY: test.unit.v

test.integration:: ## runs integration tests (real dependencies)
	@echo "* running integration tests..."
	@$(call run_pytest,tests/ -m integration -qq --tb=short)
	@echo "* integration tests done"
.PHONY: test.integration

test.integration.v:: ## runs integration tests (verbose)
	@echo "* running integration tests... (verbose)"
	@$(call run_pytest,tests/ -m integration -v)
	@echo "* integration tests done"
.PHONY: test.integration.v

test.perf:: ## runs performance tests (benchmarks, load tests)
	@echo "* running performance tests..."
	@$(call run_pytest,tests/ -m performance -qq --tb=short)
	@echo "* performance tests done"
.PHONY: test.perf

test.perf.v:: ## runs performance tests (verbose)
	@echo "* running performance tests... (verbose)"
	@$(call run_pytest,tests/ -m performance -v -s)
	@echo "* performance tests done"
.PHONY: test.perf.v

test.security:: ## runs security tests (injection, validation, XSS)
	@echo "* running security tests..."
	@$(call run_pytest,tests/ -m security -qq --tb=short)
	@echo "* security tests done"
.PHONY: test.security

test.security.v:: ## runs security tests (verbose)
	@echo "* running security tests... (verbose)"
	@$(call run_pytest,tests/ -m security -v)
	@echo "* security tests done"
.PHONY: test.security.v

test.e2e:: ## runs end-to-end tests (full system workflows)
	@echo "* running end-to-end tests..."
	@$(call run_pytest,tests/ -m e2e -qq --tb=short)
	@echo "* end-to-end tests done"
.PHONY: test.e2e

test.e2e.v:: ## runs end-to-end tests (verbose)
	@echo "* running end-to-end tests... (verbose)"
	@$(call run_pytest,tests/ -m e2e -v)
	@echo "* end-to-end tests done"
.PHONY: test.e2e.v

test.all:: test.unit test.integration test.e2e test.perf test.security ## runs all test types
	@echo "* all tests completed"
.PHONY: test.all

test.all.v:: test.unit.v test.integration.v test.e2e.v test.perf.v test.security.v ## runs all test types (verbose)
	@echo "* all tests completed (verbose)"
.PHONY: test.all.v

test.quick:: test.unit ## runs quick tests only (alias for test.unit)
.PHONY: test.quick

test.slow:: test.integration test.perf test.e2e ## runs slow tests (integration, performance, e2e)
	@echo "* slow tests completed"
.PHONY: test.slow

test:: ## runs all tests
	@echo "* running all tests..."
	@$(call run_pytest,tests/ -qq --tb=short)
	@echo "* all tests completed"
.PHONY: test

test.v:: ## runs all tests (verbose)
	@echo "* running all tests... (verbose)"
	@$(call run_pytest,tests/ -v)
	@echo "* all tests completed"
.PHONY: test.v

test.ci:: ## runs tests appropriate for CI (unit + integration)
	@echo "* running CI test suite..."
	@$(call run_pytest,tests/ -m "unit or integration" -qq --tb=short)
	@echo "* CI test suite completed"
.PHONY: test.ci

test.coverage:: ## runs tests with coverage analysis (configurable via INFRA_PYTEST_COVERAGE_MARKERS)
	@echo "* running tests with coverage analysis..."
	@rm -rf $(_COVERAGE_DIR) 2>/dev/null || true
	@mkdir -p $(_COVERAGE_DIR)
	@COVERAGE_FILE=$(_COVERAGE_DIR)/data $(call run_pytest,tests/ $(_COVERAGE_MARKER_ARG) -qq --no-header --cov=$(INFRA_PYTEST_COVERAGE_PKG) --cov-report=term --cov-report=xml:$(_COVERAGE_DIR)/coverage.xml)
	@echo "* coverage analysis completed (XML report: $(_COVERAGE_DIR)/coverage.xml)"
.PHONY: test.coverage

test.coverage.v:: ## runs tests with coverage analysis (verbose, shows missing lines)
	@echo "* running tests with coverage analysis... (verbose)"
	@$(call run_pytest,tests/ $(_COVERAGE_MARKER_ARG) -v --cov=$(INFRA_PYTEST_COVERAGE_PKG) --cov-report=term-missing)
	@echo "* coverage analysis completed"
.PHONY: test.coverage.v

test.coverage.html:: ## generates HTML coverage report
	@echo "* running tests with coverage analysis..."
	@$(call run_pytest,tests/ $(_COVERAGE_MARKER_ARG) --cov=$(INFRA_PYTEST_COVERAGE_PKG) --cov-report=html)
	@echo "* HTML coverage report generated in .htmlcov/ directory"
.PHONY: test.coverage.html

test.coverage.json:: ## generates JSON coverage report
	@echo "* running tests with coverage analysis..."
	@$(call run_pytest,tests/ $(_COVERAGE_MARKER_ARG) --cov=$(INFRA_PYTEST_COVERAGE_PKG) --cov-report=json)
	@echo "* JSON coverage report generated as .coverage.json"
.PHONY: test.coverage.json

test.coverage.rank:: ## shows files ranked by missed lines (descending)
	@$(MAKE) test.coverage 2>&1 | grep -E "$(INFRA_PYTEST_COVERAGE_PKG).*[0-9]+\s+[1-9]" | awk '{print $$3, $$1}' | sort -rn | head -20
.PHONY: test.coverage.rank
